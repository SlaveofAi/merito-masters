// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ivssecjzxhabahdapfko.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2c3NlY2p6eGhhYmFoZGFwZmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMwOTk4OTEsImV4cCI6MjA1ODY3NTg5MX0.FCZlLf3VU9nFE-4tnNNJewUQFhX0F_OV8F1XQm-VLmI";

// Create Supabase client with improved fetch configuration for stability
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: localStorage
    },
    global: {
      fetch: (url: RequestInfo | URL, options?: RequestInit) => {
        // Enhanced fetch with retry mechanism for better reliability
        const maxRetries = 5; // Increased from 3 to 5
        let retryCount = 0;
        
        const fetchWithRetry = async (): Promise<Response> => {
          try {
            const response = await fetch(url, {
              ...options,
              // Add timeout to prevent hanging requests - extended timeout
              signal: options?.signal || (AbortSignal.timeout ? AbortSignal.timeout(30000) : undefined),
              // Add cache control headers to avoid caching issues
              headers: {
                ...(options?.headers || {}),
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache',
              } as HeadersInit,
            });
            
            // If we get a server error (503, 502, 500, etc), retry after a delay
            if ((response.status === 503 || response.status === 502 || response.status === 500) && retryCount < maxRetries) {
              retryCount++;
              // Use exponential backoff with jitter for better distribution of retries
              const baseDelay = Math.min(1000 * Math.pow(2, retryCount), 15000);
              const jitter = Math.random() * 1000; // Add up to 1 second of random jitter
              const delay = baseDelay + jitter;
              console.log(`Got ${response.status} response, retrying in ${Math.round(delay)}ms (attempt ${retryCount} of ${maxRetries})`);
              
              return new Promise(resolve => {
                setTimeout(() => resolve(fetchWithRetry()), delay);
              });
            }
            
            return response;
          } catch (err: any) {
            if (err.name === 'AbortError') {
              console.error('Fetch request timed out');
              
              // Retry if we haven't exceeded max retries
              if (retryCount < maxRetries) {
                retryCount++;
                // Exponential backoff with jitter
                const baseDelay = Math.min(1000 * Math.pow(2, retryCount), 15000);
                const jitter = Math.random() * 1000;
                const delay = baseDelay + jitter;
                console.log(`Request timed out, retrying in ${Math.round(delay)}ms (attempt ${retryCount} of ${maxRetries})`);
                
                return new Promise(resolve => {
                  setTimeout(() => resolve(fetchWithRetry()), delay);
                });
              }
            }
            
            throw err;
          }
        };
        
        return fetchWithRetry();
      },
      headers: {
        'X-Client-Info': 'lovable-app',
      }
    },
    // Increase realtime timeout settings
    realtime: {
      timeout: 60000, // 60 seconds
      heartbeatIntervalMs: 30000 // 30 seconds
    }
  }
);

// Simple connection check function with retry
export const checkConnection = async (retries = 5): Promise<boolean> => { // Increased from 3 to 5
  let attempt = 0;
  
  while (attempt < retries) {
    try {
      const { error } = await supabase.from('profiles').select('id').limit(1);
      if (!error) return true;
      
      attempt++;
      console.log(`Connection check failed (attempt ${attempt}/${retries}): ${error.message}`);
      await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));
    } catch (e) {
      attempt++;
      console.error(`Connection check exception (attempt ${attempt}/${retries}):`, e);
      await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));
    }
  }
  
  return false;
};

// Check Supabase Realtime connection with improved reliability
export const checkRealtimeConnection = async (retries = 5): Promise<boolean> => { // Increased from 3 to 5
  let attempt = 0;
  
  while (attempt < retries) {
    try {
      // Create a temporary channel for testing realtime connection
      const testChannelName = `test-connection-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
      const channel = supabase.channel(testChannelName);
      
      // Subscribe to the channel and return a promise
      const connectionPromise = new Promise<boolean>((resolve) => {
        // Set a timeout in case subscription hangs - extended timeout
        const timeout = setTimeout(() => {
          console.log(`Realtime connection check timed out (attempt ${attempt + 1}/${retries})`);
          resolve(false);
        }, 10000); // Extended from 5000 to 10000
        
        channel
          .on('system', { event: 'connected' }, () => {
            clearTimeout(timeout);
            console.log('Realtime connection established');
            resolve(true);
          })
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              // Already handled by the 'connected' event
            } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
              clearTimeout(timeout);
              console.log(`Realtime subscription failed with status: ${status}`);
              resolve(false);
            }
          });
      });
      
      // Wait for the connection result
      const isConnected = await connectionPromise;
      
      // Clean up the test channel
      supabase.removeChannel(channel);
      
      // If connection successful, return true
      if (isConnected) return true;
      
      // Otherwise retry with exponential backoff
      attempt++;
      const delay = 1000 * Math.pow(2, attempt);
      console.log(`Will retry realtime connection in ${delay}ms`);
      await new Promise(r => setTimeout(r, delay));
      
    } catch (e) {
      attempt++;
      console.error(`Realtime connection check error (attempt ${attempt}/${retries}):`, e);
      await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));
    }
  }
  
  return false;
};
