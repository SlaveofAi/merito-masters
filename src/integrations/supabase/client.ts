
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ivssecjzxhabahdapfko.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2c3NlY2p6eGhhYmFoZGFwZmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMwOTk4OTEsImV4cCI6MjA1ODY3NTg5MX0.FCZlLf3VU9nFE-4tnNNJewUQFhX0F_OV8F1XQm-VLmI";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: localStorage
    },
    realtime: {
      params: {
        eventsPerSecond: 10
      },
      heartbeatIntervalMs: 1000,  // More frequent heartbeat
      reconnectAfterMs: (retryCount) => {
        // Shorter initial delay (200ms) with exponential backoff
        const delay = Math.min(200 * (Math.pow(1.5, retryCount)), 10000);
        console.log(`Realtime reconnecting in ${delay}ms (attempt ${retryCount})`);
        return delay;
      },
      // Shorter timeout to detect issues faster
      timeout: 10000
    }
  }
);

// Enhanced connection check function with retry logic and timeout
export const checkRealtimeConnection = async (): Promise<boolean> => {
  return new Promise((resolve) => {
    try {
      // Create a test channel with a unique name to avoid conflicts
      const channelId = `connection-test-${Date.now()}`;
      const testChannel = supabase.channel(channelId);
      
      // Set a shorter timeout for connection test (3 seconds)
      const timeoutId = setTimeout(() => {
        console.log("WebSocket connection check timed out");
        supabase.removeChannel(testChannel);
        resolve(false);
      }, 3000);
      
      // Add specific handlers for various states
      testChannel
        .on('system', { event: 'error' }, () => {
          console.error("WebSocket system error during connection test");
          clearTimeout(timeoutId);
          supabase.removeChannel(testChannel);
          resolve(false);
        })
        .on('system', { event: 'closed' }, () => {
          console.error("WebSocket closed during connection test");
          clearTimeout(timeoutId);
          supabase.removeChannel(testChannel);
          resolve(false);
        })
        .on('system', { event: 'open' }, () => {
          console.log("WebSocket opened during connection test");
          // Don't resolve yet - wait for subscription to complete
        });
      
      // Subscribe to the channel with success state
      testChannel.subscribe((status) => {
        console.log(`Connection test status: ${status}`);
        
        if (status === 'SUBSCRIBED') {
          clearTimeout(timeoutId);
          console.log("WebSocket connection test successful");
          supabase.removeChannel(testChannel);
          resolve(true);
        } else if (status === 'CHANNEL_ERROR' || status === 'CLOSED' || status === 'TIMED_OUT') {
          clearTimeout(timeoutId);
          console.error(`WebSocket connection test failed with status: ${status}`);
          supabase.removeChannel(testChannel);
          resolve(false);
        }
      });
      
      // Apply a second layer of timeout as a safety measure
      const backupTimeoutId = setTimeout(() => {
        console.error("WebSocket connection test backup timeout triggered");
        clearTimeout(timeoutId);
        supabase.removeChannel(testChannel);
        resolve(false);
      }, 5000);
      
      testChannel.subscribe((status) => {
        if (status === 'SUBSCRIBED' || status === 'CHANNEL_ERROR' || status === 'CLOSED' || status === 'TIMED_OUT') {
          clearTimeout(backupTimeoutId);
        }
      });
      
    } catch (error) {
      console.error('Error in WebSocket connection test:', error);
      resolve(false);
    }
  });
};
