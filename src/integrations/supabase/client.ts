// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ivssecjzxhabahdapfko.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2c3NlY2p6eGhhYmFoZGFwZmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMwOTk4OTEsImV4cCI6MjA1ODY3NTg5MX0.FCZlLf3VU9nFE-4tnNNJewUQFhX0F_OV8F1XQm-VLmI";

// Create Supabase client with improved fetch configuration for stability
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: localStorage
    },
    global: {
      fetch: (url: RequestInfo | URL, options?: RequestInit) => {
        // Enhanced fetch with retry mechanism for better reliability
        const maxRetries = 3;
        let retryCount = 0;
        
        const fetchWithRetry = async (): Promise<Response> => {
          try {
            const response = await fetch(url, {
              ...options,
              // Add timeout to prevent hanging requests
              signal: options?.signal || (AbortSignal.timeout ? AbortSignal.timeout(15000) : undefined),
            });
            
            // If we get a 503, retry after a delay
            if (response.status === 503 && retryCount < maxRetries) {
              retryCount++;
              const delay = Math.min(1000 * Math.pow(2, retryCount), 10000); // Exponential backoff
              console.log(`Got 503 response, retrying in ${delay}ms (attempt ${retryCount} of ${maxRetries})`);
              
              return new Promise(resolve => {
                setTimeout(() => resolve(fetchWithRetry()), delay);
              });
            }
            
            return response;
          } catch (err: any) {
            if (err.name === 'AbortError') {
              console.error('Fetch request timed out');
              
              // Retry if we haven't exceeded max retries
              if (retryCount < maxRetries) {
                retryCount++;
                const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
                console.log(`Request timed out, retrying in ${delay}ms (attempt ${retryCount} of ${maxRetries})`);
                
                return new Promise(resolve => {
                  setTimeout(() => resolve(fetchWithRetry()), delay);
                });
              }
            }
            
            throw err;
          }
        };
        
        return fetchWithRetry();
      },
      headers: {
        'X-Client-Info': 'lovable-app',
      }
    }
  }
);

// Simple connection check function with retry
export const checkConnection = async (retries = 3): Promise<boolean> => {
  let attempt = 0;
  
  while (attempt < retries) {
    try {
      const { error } = await supabase.from('profiles').select('id').limit(1);
      if (!error) return true;
      
      attempt++;
      console.log(`Connection check failed (attempt ${attempt}/${retries}): ${error.message}`);
      await new Promise(r => setTimeout(r, 1000 * attempt));
    } catch (e) {
      attempt++;
      console.error(`Connection check exception (attempt ${attempt}/${retries}):`, e);
      await new Promise(r => setTimeout(r, 1000 * attempt));
    }
  }
  
  return false;
};

// Check Supabase Realtime connection with improved reliability
export const checkRealtimeConnection = async (retries = 3): Promise<boolean> => {
  let attempt = 0;
  
  while (attempt < retries) {
    try {
      // Create a temporary channel for testing realtime connection
      const testChannelName = `test-connection-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
      const channel = supabase.channel(testChannelName);
      
      // Subscribe to the channel and return a promise
      const connectionPromise = new Promise<boolean>((resolve) => {
        // Set a timeout in case subscription hangs
        const timeout = setTimeout(() => {
          console.log(`Realtime connection check timed out (attempt ${attempt + 1}/${retries})`);
          resolve(false);
        }, 5000);
        
        channel
          .on('system', { event: 'connected' }, () => {
            clearTimeout(timeout);
            console.log('Realtime connection established');
            resolve(true);
          })
          .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
              // Already handled by the 'connected' event
            } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
              clearTimeout(timeout);
              console.log(`Realtime subscription failed with status: ${status}`);
              resolve(false);
            }
          });
      });
      
      // Wait for the connection result
      const isConnected = await connectionPromise;
      
      // Clean up the test channel
      supabase.removeChannel(channel);
      
      // If connection successful, return true
      if (isConnected) return true;
      
      // Otherwise retry
      attempt++;
      await new Promise(r => setTimeout(r, 1000 * attempt));
      
    } catch (e) {
      attempt++;
      console.error(`Realtime connection check error (attempt ${attempt}/${retries}):`, e);
      await new Promise(r => setTimeout(r, 1000 * attempt));
    }
  }
  
  return false;
};
